Title:  Writeup for Project 3, Fall 2015
Date:  11/10/2015
Group 8
James Lynch	jamestly@usc.edu
Austin Spiegel	aspiegel@usc.edu
Haley Lenner	lenner@usc.edu
 
I. Requirements:

The requirements for this Project are to implement the software-managed TLB, virtual memory, and RPC calls for creating Locks and Condition Variables.  The TLB acts as a cache and gives the illusion of fast access to virtual address translation over a large address space.  Virtual memory is implemented to use main memory as a cache for the disk.  This allows us to concurrently run programs that are larger than main memory, reading 'pages' of code or data from either the executable or a swap file.


II. Assumptions:


III. Design:
/*** OVERALL ***/
Exec, Fork, and Exit stay the same.  There are a handful of new functions to deal with a PageFault exception.  These new functions are described in depth below.  A PageFault exception can 'trickle up' and cause a handful of other behaviors.  The general flow of a PageFault exception is as follows:

PageFault_Handler (if page is not in TLB) -> IPTMissHandler (if page is not in memory) -> MemoryFull_Handler (if memory is full)

To model memory, we use an inverted page table (IPT).  The inverted page table stores the same data as the TLB, with the addition of the pages address space.  This allows us to modify the physical page's corresponding virtual page (load into/remove from memory).  We use memBitMap to allocate free space within main memory.  Additionally, we acquire/release memLock when searching or changing the IPT/main memory.  

AddrSpace saw some changes as well.  The PageTable now also stores whether the page is 'swapped' (saved to the SwapFile) and the pages offset in the either the executable or swapFile.  We no longer preload the executable, because there is not enough space in main memory to do so.  We've added two new functions, SavetoMemory and RemoveFromMemory which allows us to load/save virtual page data.  These are explained in greater detail below.

/*** PageFault_Handler ***/
This is the function called when a PageFault exception occurs.  A PageFault exception occurs when a virtual address is not in the TLB.

We calculate the VPN, so that we know which virtual page to put in the TLB.  We then acquire the memLock because we will be looping through the IPT.  

As we loop through the IPT, we search for a physical page with the same VPN as the VPN we calculated earlier.  If we find such a page, we check to see that it is valid and that it exists in the same address space as our currentThread.  A page cannot be trusted if it is not valid.  Additionally, multiple physical pages can have the same VPN because they can be from different address spaces.

If we find the physical page we are looking for, we break out of the loop.  Now, we turn off interrupts as we are about to update the TLB.  We check if the PPN we found is not equal to -1.  int PPN is initialized to -1; if the VPN we were looking for is not in the IPT, PPN stays equal to -1.  If PPN is equal to -1, we call IPTMiss_Handler... explained below.

If the PPN is not equal to -1, we know that the correct page is in main memory.  We update the tlbCounter, which is an index to the TLB entry we will be evicting.  Before evicting from the TLB, we check if the page we are about to evict is valid. If the page is valid, we want to propagate the dirty bit to the IPT.

We then update the TLB, copying over the corresponding data from the IPT and setting the valid bit to true.  We release memLock and turn off interrupts.

/*** IPTMiss_Handler ***/
This function is only called from PageFault_Handler.  It is called if the desired VPN was not found in the IPT.  Thus, the IPT needs to read the corresponding page in from disk or swap file.

First, we find a spot in main memory to load the missing page into.  If there is no space available, we call MemoryFull_Handler... explained below.

If we are using FIFO memory replacement scheme, we push the new physical page number on to the back of the memory queue.  We then load the page into memory via the currentThread's address space... explained below.  Finally we return the new physical page number so that the PageFault_Handler knows what information to load into the TLB.

/*** MemoryFull_Handler ***/
This function is called when we are looking for a spot in main memory to place a page from disk/swap file, but main memory is full.  We need to find a page to evict, by calling GetPageToEvict()... explained below.

We then loop through the TLB, checking if the physical page we are about to evict exists in the TLB.  If it does, and it is valid, we propagate the dirty information to the IPT.  We use the address space of the page we are about to evict to save remove the page from main memory... explained below.

/*** GetPageToEvict ***/
This function decides which page to evict depending on what eviction scheme is being used.  If the FIFO memory eviction scheme is being used, we pop a physical page number from the front of the queue.  If the random memory eviction scheme is being used, we randomly choose a physical page to evict.  In either case we return the physical page number to be evicted.

/*** ADDRSPACE ***/
AddrSpace(OpenFile* executable): This function has been changed greatly since Project 2.  We create the pageTableLock, which protects the address space's page table while it is being edited.  We then save the executable to a pointer within the address space (as opposed to deleting it, as was done previously).  We acquire the pageTableLock and create a new pageTable.  The pageTable has enough pages for the code, init data, and uninit data from the executable, as well as one userStack for the first thread in the process.  We loop through the pageTable, initializing any pages that came from the executable with their offset (virtual page's address within the executable) and VPN.  We then loop through the pages in the userStack, setting their VPN but purposely not setting their offset as they do not exist in the executable (they're blank pages).  Finally, we release the pageTableLock.

LoadIntoMemory(int vpn, int ppn): This function is new for Project 3.  In this function, we load a virtual page from disk or swap file into main memory.  This function is only ever called upon a PageFaultException.  Therefore, we do not worry about acquiring the memLock because it has been acquired by the calling function.

First, we acquire the pageTableLock as we will be modifying information in the pageTable.  There are 3 possibilities for loading:

	Swapped: If the virtual page has been swapped, we read pageSize bytes in from the swapFile where the virtual page's offset is.  We then clear the swapBitMap of that page, so that the space in the swapFile can be used by other data.  We set the swapped flag to false, the offset to -1, and the physical page's dirty bit to true (because this page is modified data).

	Executable: If the virtual page is in the executable, we read pageSize bytes in from the executable where the virtual page's offset is.  We then set the physical page's dirty bit to false because we are loading unmodified code or data.

	Neither: The page can exist in neither the swap file nor the executable if the page is a blank userStack page.  In this case, we just set the physical page's dirty bit to false because the page has yet to be modified.

Following all cases, we copy the virtual page's information into the corresponding index in the IPT.  We also set the virtual page's physical page number to its new PPN and set its valid bit to true (because it is in main memory).

RemoveFromMemory(int vpn, int ppn): This function is new for Project 3.  In this function, we update the address space's pageTable to reflect that the virtual page has been removed from memory.  If the physical page is dirty, we save it to a swap file.

First, we acquire the pageTableLock.  If the physical page is dirty, we find a location in the swapFile to save it to (using the swapBitMap).  We then write pageSize bytes from the physical page's location in main memory to the allocated location in the swapFile.  We save the virtual page's offset as the 'swapPage' * PageSize and set the swapped flag to true.  Regardless of whether or not the physical page is dirty, we reset the virtual page's physical page number and set its valid bit to false (because it is no longer in main memory).  Finally, we release the pageTableLock.

InitRegisters(): This function has barely changed.  We acquire the pageTableLock at the beginning of this function because we will be using the numPages to calculate the StackReg address and do not want it to be modified by a new thread if a context switch occurs.

SaveState(): This function has been modified.  On a context switch, we want to invalidate the TLB.  Whenever dealing with the TLB, we turn off interrupts.  We loop through the TLB, and if a TLB entry is valid, we propogate it's dirty bit.  We set all TLB enetries to invalid.

NewUserStack(): This function has a new name (used to be NewPageTable) and also initializes the new fields in pageTableEntry (offset & swapped).

ReclaimStack(int stackPage):  We disable interrupts for this function because it will modify the TLB.  We loop through a thread's userStack (stackPage + (UserStackSize / PageSize)) checking if any of its virtual page's are in main memory.

If they are, we invalidate the entry in the IPT and check the TLB.  If the physical page is also in the TLB (and it is valid), we invalidate it.  Finally, we clear the memBitMap of the physical page so it can be used by other processes.  If using the FIFO memory management scheme, we remove the physical page number from the queue.

We also check if the page has been swapped, if so we clear the swapBitMap of the virtual page so that it can be used by other processess.

Finally, we reset all of the virtual page's information and disable interrupts.

ReclaimPageTable():  ReclaimPageTable is identical to ReclaimStack except we loop through the entire pageTable instead of a single userStack.

IV. Implementation:
+ Files Modified: 
	System.h
	System.cc
	Syscall.h
	exception.cc
	addrspace.h
	addrspace.cc
	progtest.cc
	start.s

+ Files added:
	execTest.c
	forkTest.c

+ Data Structures added/modified

	/*** SYSTEM ***/
    class IPTEntry : public TranslationEntry
    {
        public:
            AddrSpace * space; // Process memory belongs to
    };

    IPTEntry *ipt;
    OpenFile *swapFile;
    BitMap *swapBitMap;
    bool isFIFO;
    list<int> memFIFO;
    int tlbCounter;

    /*** ADDRSPACE ***/
    class PageTableEntry : public TranslationEntry
	{
	    public:
	        PageTableEntry(); // Initialize a Page Table Entry
	        ~PageTableEntry(); // De-allocate Page Table Entry
	        bool swapped; // In swap file? If !swapped && !valid, then load from executable
	        int offset; // The last bits of virtual address for access within Page
	};

	Lock *pageTableLock;
	OpenFile *executable;

+ Functions added and in which file.

addrspace.cc
	PageTableEntry::PageTableEntry()
	void AddrSpace::LoadIntoMemory(int vpn, int ppn)
	void AddrSpace::RemoveFromMemory(int vpn, int ppn)
	int AddrSpace::NewUserStack()

exception.cc
	unsigned int GetPageToEvict()
	int MemoryFull_Handler()
	int IPTMiss_Handler(int vpn)
	void PageFault_Handler(unsigned int vaddr)
	void ExceptionHandler(ExceptionType which)




+ Functions modified and in which file.
progtest
	void StartProcess(char *filename)

syscall.h
	int WriteOne(char* buf, int size, int num1)
	int WriteTwo(char* buf, int size, int num1, int num2)
	void WriteError(char* buffer, int size)
	int WriteInt(int integer)
	int Random(int lower, int upper)

	int CreateLock(char* name, int size) 
	int AcquireLock(int indexlock)
	int ReleaseLock(int indexlock)
	int DestroyLock(int indexlock)

	int CreateCV(char* name, int size)
	int Wait(int indexcv, int indexlock)
	int Signal(int indexcv, int indexlock)
	int Broadcast(int indexcv, int indexlock)
	int DestroyCV(int indexcv)

	void Halt()
	void Yield() 
	void Exit(int status)
	void Fork(char* name, int len, void (*func)())
	void Exec(char* name, int len)

system.cc/system.h
	void Cleanup()
	void Initialize()

addrspace.cc/addrspace.h
	Addrspace()
	int InitRegisters()
	void SaveState()
	int NewUserStack()
	void ReclaimStack(int stackPage)
	void ReclaimPageTable()

exception.cc
	void WriteInt_Syscall(int integer)
	int Random(int lower, int upper)
	int WriteOne(unsigned int vaddr, int len, int num1)
	int WriteTwo(unsigned int vaddr, int len, int num1, int num2)
	void WriteError_Syscall(unsigned int vaddr, int len)
	
	int checkLockErrors(int index)
	int CreateLock_Syscall(unsigned int vaddr, int len) 
	int AcquireLock(int indexlock)
	void DeleteLock(int indexlock)
	int ReleaseLock(int indexlock)
	int DestroyLock(int indexlock)

	int checkCVErrors(int indexcv, int indexlock)
	int CreateCV(unsgned int vaddr, int len)
	int Wait(int indexcv, int indexlock)
	void DeleteCondition(int indexcv)
	int Broadcast(int indexcv, int indexlock)
	int DestroyCV(int indexcv)

	void Halt()
	void Yield_Syscall() 
	void Exit_Syscall(int status)
	void Kernel_Thread(int vaddr)
	void Fork_Syscall(unsigned int vaddr, int len, unsigned int vFuncAddr)
	void Exec_Thread()
	void Exec_Syscall(int vaddr, int len)
	void ExceptionHandler(ExceptionType which)

V. Testing:  (For each test case, you must show)
+ How to test

/*** PARTS 1 & 2 ***/
nachos -x ../test/matmult
	// This runs matmult once and finishes correctly
nachos -x ../test/sort
	// This runs sort once and finishes correctly
nachos -x ../test/execTest
	// This execs 2 matmults, the main thread and 2 process threads finish correctly
nachos -x ../test/forkTest
	// This forks matmult once and finishes correctly

+ Test Output
matmult: Exit: 7220
sort: Exit: 1023
execTest: Exit: 0 \n Exit: 7220 \n Exit: 7220
forkTest: Exit: 0 \n Exit: 7220

VI. Discussion:


