Title:  Writeup for Project 2, Fall 2015
Date:  10/20/2015
Group 8
James Lynch	jamestly@usc.edu
Austin Spiegel	aspiegel@usc.edu
Haley Lenner	lenner@usc.edu
 
I. Requirements:

The requirements of the assignment is to create userprograms that can interact with the operating system via syscalls. Basically
put up a wall between the userprogram and OS code because userprograms are not directly allowed to called operating system code,
they need to request to do something w/ the operating system and then let the operating system actually perform the function. This also needs to simulate the idea that user programs can only create changes within their own programs and cannot access/create locks or conditions in processes that are not their own. The OS needs to handle these syscalls and perform the action required depending on whether the input is valid or not. We also are implementing several userprog tests to ensure the program works and also convert passport office to c so it can be run as a userprog.


II. Assumptions:
-

III. Design:

Our design idea is to create kernel lock and kernel cv structs and a process struct. These structs will hold Lock *lock, AddrSpace *space, and bool toDelete (locktest).Condition *condition, AddrSpace *space, and bool toDelete (conditiontest). The process will hold the number of executing threads, sleeping threads, address space, and an id for the process. Each of these structs will be stored in vectors, and all of the syscalls will use the vector for quick lookup. These vectors need to be accessed by userprogs one at a time to avoid race conditions so we'll put locks around all of the vectors. The goal is to ultimately make sure that the process addspace is the same space as the lock addspace and the cv addspace when making verifications, to make sure it has the proper access to do so and the lock/cv belongs to the process. For all syscalls we are going to validate the input passed in, which will be vaddr, length, lock indeces, and cv indeces. These all must be within bounds and nonnegative. For createLock, after validation we are going to create a new kernellock struct and then populate the struct addrspace with curr addrspace, delete=false, and an actual associated lock. Then we will push it to the back of the vector of kernellock struct pointers. For Acquire, we will pass in the index of the kernel lock struct and then do validations. Then update the process table numExecuting threads(-1) and sleeping threads (+1), then call the actual OS method to acquire the lock to run the OS code. Then after that code runs it means the thread is no longer sleeping so we need to increment the numExecutingThreads and decrement sleeping. These are accessing process table so we'll need to acquire the process table lock when making changes. For release lock we will release the lock at the index after validations. Release also needs to prompt a check for destroy, because if todelete is true and this was the last thread to release the lock then destroyLock will need to be called. For DestroyLock, we pass in indexes and do valiadtion tests and then check if todelete is set to true. if it is set to true and the queue for the lock is empty then we'll delete it and if it's not set to true or the wait queue is empty then we will set it to true, and wait for the waitqueue to be empty. 

For createCV, after validation we are going to create a new kernelcv struct and then populate the struct addrspace with curr addrspace, delete=false, and an actual associated cv. Then we will push it to the back of the vector of kernelcondition struct pointers. For wait, we are updating the process table numExecuting threads(-1) and sleeping threads (+1), then call the actual OS method to wait / run the OS code. Then after that code runs it means the thread is no longer sleeping so we need to increment the numExecutingThreads and decrement sleeping. These are accessing process table so we'll need to acquire the process table lock again when making changes. We will need to know the index cv and index lock of what we are waiting on and do validations for these as well. For signal we will wake up the thread waiting on the cv after validations and then check destroylock to see if the thread was the last thread in the sleepqueue for the cv and the cv should be deleted. Broadcast also needs to check if destroylock is true but does not need to check the wait queue since nobody will be asleep on that queue once everyone is woken up. For broadcast and signal, we are again calling the OS broadcast and signal methods in the OS after creating temporary kernelcv with the parameter index which calls the method on the lock from the lock vector at the parameter index. For DestroyCV, we pass in indexes and do valiadtion tests and then check if todelete is set to true. We are not deleting the actual struct objects for cvs or locks because that would change the indexes of everyting in the vector. If toDelete is set to true and the queue for the lock is empty then we'll delete it and if it's not set to true or the wait queue is empty then we will set it to true, and wait for the waitqueue to be empty. If conditions succeed and can be deleted, we are setting the structs to null and then removing the actual lock and condition inside to keep indeces the same.



IV. Implementation:
+ Files Modified: 
	System.h
	System.cc
	Syscall.h
	exception.cc
	addrspace.cc
	start.s
	thread.cc - added passportID
	progtest

+ Files added:
	passporttest.cc
	test1.cc
	test2.cc
	test3.cc
	test4.cc
	test5.cc
	test6.cc

+ Data Structures added/modified

    Machine *machine;
    BitMap *memBitMap;
    vector<KernelLock*> locks;
    vector<KernelCV*> conditions;
    vector<Process*> processInfo;
    Lock *memLock;
    Lock *processLock;
    Lock *conditionsLock;
    Lock *locksLock;

        struct KernelLock
    {
        Lock *lock;
        AddrSpace *space;
        bool toDelete;      
    };

    // KernelCV extra info for cleaning up and guaranteeing process CV ownership
    struct KernelCV
    {
        Condition *condition;
        AddrSpace *space;
        bool toDelete;
    };  

    struct Process
    {
    	AddrSpace *space;
    	int numSleepingThreads;
    	int numExecutingThreads;
    	int processID;
    };

+ Functions added and in which file.

exception.cc
	void Kernel_Thread(int vaddr)
	void WriteInt_Syscall(int integer)
	void WriteError_Syscall(unsigned int vaddr, int len)
	int checkLockErrors(int index)


-- Functions to test simulation:

test1();
test2();
test3();
test4();
test5();
test6();
test7();

+ Functions modified and in which file.
progtest
	void StartProcess(char *filename)

syscall.h
	int CreateLock_Syscall(unsigned int vaddr, int len) 
	void DeleteLock(int indexlock)
	int ReleaseLock(int indexlock)
	int DestroyLock(int indexlock)
	int Wait(int indexcv, int indexlock)
	int Broadcast(int indexcv, int indexlock)
	int DestroyCV(int indexcv)
	void Halt()
	void Yield_Syscall() 
	void Exit_Syscall(int status)
	void Fork_Syscall(unsigned int vaddr, int len, unsigned int vFuncAddr)
	void Exec_Thread()
	void Exec_Syscall(int vaddr, int len)
	void ExceptionHandler(ExceptionType which) 

system.cc/system.h
	void Cleanup();
	void Initialize();

addrspace.cc/addrspace.h
	constructor

exception.cc
	void WriteInt_Syscall(int integer)
	void WriteError_Syscall(unsigned int vaddr, int len)
	int checkLockErrors(int index)
	int CreateLock_Syscall(unsigned int vaddr, int len) 
	void DeleteLock(int indexlock)
	int ReleaseLock(int indexlock)
	int DestroyLock(int indexlock)
	int Wait(int indexcv, int indexlock)
	int Broadcast(int indexcv, int indexlock)
	int DestroyCV(int indexcv)
	void Halt()
	void Yield_Syscall() 
	void Exit_Syscall(int status)
	void Kernel_Thread(int vaddr)
	void Fork_Syscall(unsigned int vaddr, int len, unsigned int vFuncAddr)
	void Exec_Thread()
	void Exec_Syscall(int vaddr, int len)
	void ExceptionHandler(ExceptionType which) 



V. Testing:  (For each test case, you must show)
+ How to test

To test the lock and cv syscalls, go to userprog and type the following:
run lock and condition tests = 
	'nachos -x ../test/test1’
	'nachos -x ../test/test2'
	'nachos -x ../test/test3’
	'nachos -x ../test/test4’
	'nachos -x ../test/test5’
	'nachos -x ../test/test6’
	'nachos -x ../test/test7’

run passport office = 'nachos -x ../test/passporttest'

+ Test Output

- Our output will say pass/fail for validation tests 1-4. For test 5, it shows we support mutual exclusion and lock functionality is in place with syscalls by acquiring and releasig lock 1, then lock 2, then lock 3. There should not be any overlap since they are all acquiring the same lock. Test 6 is showing how broadcast works by waiting on a condition variable and then being woken up by the thread who acquired the lock and called broacast, and then printing out to console when things are woken up. 

test1-
	output should say pass or fail
test2-
	output should say pass or fail
test3-
	output should say pass or fail
test4-
	output should say pass or fail
test5-
	Passed if acquired GREEN printed acquired/released numbers are in increasing order/non overlapping. This means people are properly acquiring and releasing locks. This tests all lock functions.
test6-
	Passed if FINISHED green numbers are in increasing order. This means that things were executing in the proper order and the broadcast woke every thread up and then they acquired and released the threads according to the order in which they were forked. This tests signal and broadcast and shows that wait works as well, since threads are waiting to be broadcasted.
test7- 
	This test we added console output within the code to walk through what was happening. The order of what happens should be the following: 
		-Thread 1 forked
		-Thread 2 forked
		-Thread 3 forked
		-Thread 1 acquires a lock and immediately Waits on the cv and lock. 
		-Thread 2 acquires the lock and then tries to destroy the CV but cannot because thread 1 is waiting on it so the sleepqueue is not empty, so 
		-^this sets toDelete to true.
		-Thread 2 waits on the same cv and lock
		-Thread 3 acquires the lock
		-Thread 3 broadcasts 
		-Thread 1 and 2 wake up, respectively
		-ToDelete was set to true, the condition is deleted.
		-Thread 3 releases the lock.
		done

VI. Discussion:

All of our syscalls work. Along with fork exec and exit. We did not write our tests to run with -rs values. Our tests display proper functionality for the syscalls, fork exec and exit and the simulation works.

