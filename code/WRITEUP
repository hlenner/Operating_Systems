Title:	Writeup for Project 4, Fall 2015
Date:	12/03/2015
Group 8
James Lynch		jamestly@usc.edu
Austin Spiegel	aspiegel@usc.edu
Haley Lenner	lenner@usc.edu
 


I. Requirements:

The requirements for this project are to create a fully distributed passport office.  This involves two parts.  The first part focuses on splitting up the monolithic passport office program into many separate programs.  Each program is a different role from the passport office (i.e. passportClerk, pictureClerk, cashier, etc.).  The new passport office will now run on 5 different clients communicating with 5 different servers.  In doing this, we lost the ability to have global shared data.  Global data will now reside in monitor variables on the servers.  Locks, condition variables, and monitor variables will be distributed amongst the 5 different servers, but they will effectively exist in the same address space.  The second part of this project involves ensuring that the distributed data is accessible by all 5 servers.  When accessing a lock, condition variable, or monitor variable, each 'role' program will contact a random server.  This server may or may not have the resource the program is attempting to access.  In that situation, the server must contact the other servers and forward the request.  The resources have their own intricacies, and distributed requests for them must be handled in specific ways.

II. Assumptions:
	-there is a random chance of customers going to an application line vs a picture line first.
	-filing an application and picture take a random time, between 20 and 100 yields.
	-being punished takes 100-1000 yields
	-customers sometimes go to the passport and cashier lines too early, in which case they are punished and go to the back of the passport line (They can now decide again which passport line is shortest).
	-Manager will wake up an additional clerk when there are three people in any line, if not all are currently awake. People only get in a line that is active. If everyone is on break, the manager will wake up a clerk when a customer goes into their line
	-money values of 100 600 1100 and 1600 are randomly distributed.
	-the user can enter invalid input. must test for that.
	-the customer ALWAYS bribes the clerk, if they have the money to do so. 
	-you pick the shortest line based on the normal line. Then if you have the money to bribe, you get in the bribe line for that line.
	-manager’s thread gets put to sleep when all of the customers have left the passport building and nobody else is working.
	-only one senator at a time can be in the passport office. There are no senator bribe lines.
	-simulation ends when all customers are processed and there are no more customers coming into the passport line.
	-each type of clerk has their own money ‘pool,' the manager goes and reads each type of clerks money pool rather than the manager going to each individual clerk and getting the money.
	-manager only prints out the money when there is a change in the amount of money that is collected.

	- One client Execs a maximum of 10 total entities per server
	- Maximum of 5 servers
	- The forwarding server will wait for all responses or until it receives a 'yes' response from another server
	- The shared data needs to be global and can be accessed by specific entities using MVs
	- The server should not busy wait when forwarding a request to other servers- the pending request table should be used and the server continue accepting customer requests



III. Design:

	/*** PART 1 ***/
	Overall
		In initialize data we need to create the monitor variables that hold references to the monitor variables for each individual customer or clerk.

		Our design was to implement it as close to possible as original.  Every decision that has to be made by a customer or a clerk requires its own method. This includes GetBackInLine, MakePhotoDecision, ChooseLine, etc. We are using writeOutput to print to the screen just as we did for sys calls. Decide clerk was similar to the first implementation but accessing different data structures in order to get information. The customer still decides the line to get on but passes the information via changing array values and booleans. He has functions to get back in line, make photo decision, pay for passport, punish too soon, etc. Output- The clerk, manager, and customer has its own section of switch statements since they are all having different interactions. In order to write output we created a giant switch statement with nested cases of the person interaction happening, the clerk type, cases of the type of clerk,and finally if it is a senator or a customer.

	Customer // Senator
		Previously we had a struct to hold all of the customer data but now we arent using a struct to hold all of the data because it is being decentralized and globalized. Each customer has its own monitor varibale which holds the data that pertains to them, the turnedInApplication, acceptedPassport, gotPassport, applicationFiled, pictureFiled, passportCertified, and passportRecorded. We have a monitor variable for each customer that holds the customer data and then we have a monitor variable that holds all of the customer monitor variables. 

	Application // Passport // Picture // Cashier Clerk
		Previously we had a struct to hold all of the clerk data but now we arent using a struct to hold all of the data because it is being decentralized and globalized. Each clerk has a monitor variable that represents its 'counter'.  This is where the customer places data when he is communicating with the clerk.  The rest of the logic is similar to how passport office worked previously 

	Manager
		Previously we had a struct to hold all of the manager data but now we arent using a struct to hold all of the data because it is being decentralized and globalized. Each manager has its own monitor varibale which holds the data that pertains to it.The manager will access the money monitor variable every time it has an interaction with a clerk.  Collection of money is protected by a lock.  It will also wake up the clerks.  We have a monitor variable for each customer that holds the customer data and then we have a monitor variable that holds all of the customer monitor variables. 

	/*** PART 2 ***/
	We implemented shared, networked resources by splitting the server into two threads: one running ServerTasks(), and the other running Router(). 

	Router has the mailbox that receives other machine’s messages (other Clients and Servers). It’s job is to parse a request that is either (1) a Client request, (2) a Server request, or (3) a Server response. The message formats for each vary. Below:
	(1) <RequestType> <… RequestParams>
	e.g.CL AppClerkLineLock
	WC 2 93
	(2)REQ <RequestNumber> <ClientMachine> <ClientMailbox> <OriginalRequest>
	e.g.REQ 34 2 3 WC 2 93
	(3)RES <ResponseCode> <PendingNumber>
	e.g.RES 404 34

	The basic flow from a Client Request to a Server Response is as follows:
	(1)Client sends message to Server’s Mailbox 0
	(2)Router (Thread 1) checks Mailbox 0
	(3)Router calls LookupResource to find if it owns the Resource

	(A4)(302 – Owner) Router calls PerformTask
	(A5) PerformTask sends message to its Mailbox 1
	(A6)TaskServer (Thread 2) calls RPC
	(A7)(If RPC Complete) TaskServer sends a response to Client

	(B4)(404 – Not Found) Router forwards request to all other Servers
	(B5)All other Servers call LookupResource to find if they own Resource

	(BA6)(302 – Owner) Router calls PerformTask
	(BA7)(302 – Owner) Router responds YES/302 to Server
	(BA8)TaskServer (Thread 2) calls RPC
	(BA9)(If RPC Complete) TaskServer sends a response to Client
	(BA10)Router removes task from pending Requests, other Server took care of it

	(BB6)(404 – Not Found) Router responds NO/404 to Server
	(BB7)(Requesting Server) If numServers = NoCount, send Error to Client or Create Resource if call is CL, CC, or CM.
	(BB7) Router removes task from pending Requests

	(C4)(400/401 – Error) Router sends error response to Client

	Indices for server resources are assigned: index [0-99] + (netname * 100) to ensure that all Servers generate unique resource IDs.
	RPCs from Project 3 (No longer send responses – that is handled inside of TaskServer) (Wait is now split into three steps: Releasing the Lock (setting it BUSY so other threads cannot interact with Lock until Wait finishes – keeps CV::Wait atomic), Waiting on the CV (adding yourself to the waitqueue), and Freeing the Lock (taking care of all requests that built up while lock was BUSY). Signal and Broadcast verify they are the lock owners before they call Signal or Broadcast, so those tasks are split into two steps: the Lock work and the CV work. Since we have no way of knowing whether the server has both, one, or neither of the resources necessary for CV RPCs, we needed to split up the methods into their Resource-components.

	+ Functions Modified 
	Locks:
	int CreateLock(string lockname, int clientMachine, int clientMailbox);
	bool AcquireLock(int indexlock, lockstate state, int requestNumber, ClientResponse response);
	bool ReleaseLock(int indexlock, lockstate state, int requestNumber, int clientMachine, int clientMailbox);
	void DestroyLock(int indexlock, int clientMachine, int clientMailbox);
	int FreeLock(int indexlock, int requestNumber);

	Conditions:
	int CreateCV(string cvname, int machineID, int mailboxID);
	void WaitCV(unsigned int indexcv, unsigned int requestNumber, int machineID, int mailboxID);
	void SignalCV(unsigned int indexcv, int clientMachine, int clientMailbox);
	void BroadcastCV(unsigned int indexcv, unsigned int indexlock, int machineID, int mailboxID);
	void DestroyCV(unsigned int indexcv, int machineID, int mailboxID);
	void DeleteCondition(unsigned int indexcv);

	Monitor Variables:
	void CreateMV(string mvname, int mvsize, int machineID, int mailboxID);
	void SetMV(unsigned int indexmv, unsigned int indexvar, int value, int machineID, int mailboxID);
	void GetMV(unsigned int indexmv, unsigned int indexvar, int machineID, int mailboxID);
	void DestroyMV(unsigned int indexmv, int machineID, int mailboxID);

	The Server is split into two threads: One for Routing requests, and one for doing work once the resource has been validated and verified that it is on that Server. So all input params to RPCs inside of TaskServer is allowed to be completely trusted. Validation is completely handled by Router. LookupResource calls LookupLock, LookupCV, LookupMV depending on the RPC and sends back a status code of either 302 (Resource Found), 404 (Not Found), or 400/401 (Error). ForwardRequest is what’s called when Lookup returns a 404. NextResourceStep sends a message to the Router for multi-step RPCs like CV::Wait. PerformTask constructs the request and calls ScheduleTask to send TaskServer a Task. RespondToClient sends a message to the Client when an RPC has finished or there has been an Error, allowing the client to continue execution. RespondToServer sends a YES/302 or NO/404 response to a Server checking if other Servers own a resource. SendResponse builds a message and calls Send.

	Server:
	void TaskServer();
	void Router ();

	bool LookupResource (string request, int machineID, int mailboxID);
	int LookupLock(string request, int machineID, int mailboxID);
	int LookupCV(string request, int machineID, int mailboxID);
	int LookupMV(string request, int machineID, int mailboxID);

	void ForwardRequest (char *request, int machineID, int mailboxID);
	void NextResourceStep(string requestType, int requestNumber, int clientMachine, int clientMailbox);
	void PerformTask (string request, int clientMachine, int clientMailbox);
	void ScheduleTask (string request, int clientMachine, int clientMailbox);

	void RespondToClient(int responseCode, string type, int indexresource, int machineID, int mailboxID);
	void RespondToServer(int responseCode, int pendingNumber, int machineID, int mailboxID);
	void SendResponse(string response, int machineID, int mailboxID);


IV. Implementation:
Files Modified: 

	nettest.cc
	exception.cc
	thread.cc
	system.cc
	system.h
	
Files added:

	customer.c
	manager.c
	appclerk.c
	passportclerk.c
	cashierclerk.c
	pictureclerk.c
	create.h
	Exec1.c //exec's 10 entities
	Exec2.c //exec's 10 entities 
	Exec3.c //execs 10 entities
	Exec4.c // execs 10 entities 
	Exec5.c // execs 10 entities 

+ Data Structures added/modified
	We had to take out all complex data structures and change them to ints and arrays in order for them to be used for the monitor variables. We modified all of the contents within every struct to be monitor variables. Every customer, and type of clerk has a monitor variable that holds its specific data and then there is an overall monitor variable that holds all of the data for each entity. This makes the illusion of an array of structs becauese each index in the MV is a different piece of data. 
	


Functions added and in which file.

	create.h
		void InitializeCustomerData ()
		void InitializePassportClerkData ()
		void InitializeApplicationClerkData ()
		void InitializePictureClerkData ()
		void InitializeCashierData()
		void InitializeData()
		void InitializeSystemJobs()
	
	customer.c
		enum outputstatement()
		WriteOutput()
		int DecideClerk (int ssn)
		void WaitInLine (int ssn, int clerkID, enum persontype clerkType)
		void GetBackInLine (int ssn, enum persontype clerkType);
		void CustomerInteraction (int ssn, int clerkID, enum persontype clerkType)
		void GetBackInLine (int ssn, enum persontype clerkType)
		void Leave (int ssn)
		void Customer ()

	manager.c
		enum outputstatement()
		WriteOutput()
		int CollectMoney (enum persontype clerkType)
		void TakeClerksOffBreak (enum persontype clerkType)
		int ManageClerk (enum persontype clerkType)
		void Manager ()

	appclerk.c
		enum outputstatement()
		WriteOutput()
		void TakeBreak (int clerkID, enum persontype clerkType) 
		int CreateSystemJob (int ssn, int clerkID, enum persontype clerkType)
		void ResetSystemJob (int jobID)
		void RunSystemJob ()
		void ClerkInteraction (int clerkID, enum persontype clerkType)
		enum clerkinteraction DecideInteraction (int clerkID, enum persontype clerkType)
		void Clerk()

	passportclerk.c
		enum outputstatement()
		WriteOutput()
		void TakeBreak (int clerkID, enum persontype clerkType) 
		int CreateSystemJob (int ssn, int clerkID, enum persontype clerkType)
		void ResetSystemJob (int jobID)
		void RunSystemJob ()
		void ClerkInteraction (int clerkID, enum persontype clerkType)
		enum clerkinteraction DecideInteraction (int clerkID, enum persontype clerkType)
		void Clerk()

	cashierclerk.c
		enum outputstatement()
		WriteOutput()
		void TakeBreak (int clerkID, enum persontype clerkType) 
		int CreateSystemJob (int ssn, int clerkID, enum persontype clerkType)
		void ResetSystemJob (int jobID)
		void RunSystemJob ()
		void ClerkInteraction (int clerkID, enum persontype clerkType)
		enum clerkinteraction DecideInteraction (int clerkID, enum persontype clerkType)
		void Clerk()

	pictureclerk.c
		enum outputstatement()
		WriteOutput()
		void TakeBreak (int clerkID, enum persontype clerkType) 
		int CreateSystemJob (int ssn, int clerkID, enum persontype clerkType)
		void ResetSystemJob (int jobID)
		void RunSystemJob ()
		void ClerkInteraction (int clerkID, enum persontype clerkType)
		enum clerkinteraction DecideInteraction (int clerkID, enum persontype clerkType)
		void Clerk()


V. Testing:  (For each test case, you must show)
+ How to test


+ Test Output


+ Test Output

VI. Discussion:

	At this moment in time, our code is not runnable.  We have documented all of our code and wrote a very in depth writeup.  We spent more time working on Part 2.  It is code complete, but Part 1 is not complete, so it is difficult to test.  Please feel free to look through the code and ask us any questions.  We understand that it will be difficult to grade this, but the logic is all there and hopefully we can receive some credit for that.  Thank you so much for your time!
